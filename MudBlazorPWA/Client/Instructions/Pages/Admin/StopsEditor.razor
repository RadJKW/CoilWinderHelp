@page "/stops"
@using Microsoft.AspNetCore.SignalR.Client
@using MudBlazor.Extensions
@layout DocViewLayout
@inject NavigationManager NavigationManager
@implements IDisposable

<div class="stops-container">

  <div class="stops-left-column ">

    <MudPaper Class="left-column-paper mud-background-gray">



      <SidebarDirectoryTree/>
      <MudText>Selected Folder: </MudText>
      <MudText>@(SelectedValue.As<Folder>().Name)</MudText>
    </MudPaper>

  </div>
  <div class="stops-right-column">

    <MudPaper Class="mud-background-gray right-column-paper">

      <MudList>
        @if (_folders is not null) {
          foreach (var folder in _folders) {
            <MudListItem Icon="@Icons.Material.Filled.Folder"
                Text="@folder"/>
          }
        }

      </MudList>
    </MudPaper>
  </div>
</div>

@code{

  public class Folder {
    public string? Name { get; set; }
    public string? Path { get; set; }
    public List<Folder> SubFolders { get; set; } = new();
  }

  //private MudListItem? _selectedItem;
  private object SelectedValue { get; set; } = new Folder();
  private Folder? RootFolder { get; set; }
  private string[]? _folders;
  private HubConnection? _directoryHub;
  protected override async Task OnInitializedAsync() {
    await InitializeDirectoryHub();
  }

  private async Task InitializeDirectoryHub() {
    _directoryHub = new HubConnectionBuilder()
      .WithUrl(NavigationManager.ToAbsoluteUri("/directoryHub"))
      .Build();
    _directoryHub.On<string[]>("ReceivedAllFolders", (folders) => {
  // sort the folders into the dictionary based off of the first folders from the root directory
      _folders = folders;
      RootFolder = BuildDirectoryTree(_folders);
      InvokeAsync(StateHasChanged);
    });
    await _directoryHub.StartAsync();
    await _directoryHub.SendAsync("GetAllFolders", null);
  }
  private static Folder BuildDirectoryTree(IEnumerable<string> paths) {
    var root = new Folder();
  // create a var to assign the splitChar to depending on if the path contains '\\' or '/'
    var enumerable = paths.ToList();
    var splitChar = enumerable.First().Contains('\\') ? '\\' : '/';
    var splitPaths = enumerable.Select(path => path.Split(splitChar)).ToList();
    var commonParts = int.MaxValue;

    for (var i = 0; i < splitPaths[0].Length; i++) {
      var currentPart = splitPaths[0][i];
      var count = 1;
      for (var j = 1; j < splitPaths.Count; j++) {
        if (i >= splitPaths[j].Length || splitPaths[j][i] != currentPart) {
          break;
        }
        count++;
      }
      if (count == splitPaths.Count) {
        commonParts = i;
      } else {
        break;
      }
    }

    root.Name = splitPaths[0][commonParts];
    root.Path = string.Join(splitChar, splitPaths[0].Take(commonParts + 1));

    foreach (var splitPath in splitPaths) {
      var current = root;
      for (var i = commonParts + 1; i < splitPath.Length; i++) {
        var next = current.SubFolders.FirstOrDefault(f => f.Name == splitPath[i]);
        if (next == null) {
          next = new Folder() {
            Name = splitPath[i],
            Path = current.Path + splitChar + splitPath[i]
          };
          current.SubFolders.Add(next);
        }
        current = next;
      }
    }

    return root;
  }


  public void Dispose() {
    _directoryHub?.DisposeAsync();
  }
  private static RenderFragment ChildrenFolderBuilder(Folder folder) => builder => {
    var index = 0;
    foreach (var subFolder in folder.SubFolders.OrderBy(f => f.Name)){

      builder.OpenComponent<MudListItem>(index++);

      builder.AddAttribute(index++, "Icon", Icons.Material.Filled.Folder);
      builder.AddAttribute(index++, "Text", subFolder.Name);
      builder.AddAttribute(index++, "Value", subFolder);
      if (subFolder.SubFolders.Count > 0) {
        builder.AddAttribute(index++, "NestedList", ChildrenFolderBuilder(subFolder));
      }
      builder.CloseComponent();
    }
  };
}

}
