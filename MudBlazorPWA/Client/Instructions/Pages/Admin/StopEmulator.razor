@using Microsoft.AspNetCore.SignalR.Client
@using MudBlazor.Extensions
@layout DocViewLayout
@inject NavigationManager NavigationManager
@implements IDisposable

<div class="stops-container">

  <div class="stops-left-column ">

    <MudPaper Class="left-column-paper mud-background-gray">

      @if (RootFolder is not null) {
        <MudList Clickable="true">
          <MudListSubheader>
            <MudText Typo="Typo.body2">@RootFolder.Name</MudText>
          </MudListSubheader>
          @foreach (var folder in RootFolder.SubFolders.OrderBy(f => f.Name)) {
            <MudListItem Icon="@Icons.Material.Filled.Folder"
                Text="@folder.Name"
                @bind-Expanded="@folder.IsExpanded"
                OnClick="@(async () => await ToggleFolderExpanded(folder))"
                NestedList="@folder.ChildrenFolders">
            </MudListItem>
          }




        </MudList>
      }
      <MudText>Selected Folder: </MudText>
      <MudText>@(SelectedFolder.As<Folder>().Name)</MudText>
    </MudPaper>

  </div>
  <div class="stops-right-column">

    <MudPaper Class="mud-background-gray right-column-paper">

      <MudList>
        @if (_folders is not null) {
          foreach (var folder in _folders) {
            <MudListItem Icon="@Icons.Material.Filled.Folder"
                Text="@folder"/>
          }
        }

      </MudList>
    </MudPaper>
  </div>
</div>

@code{

  public class Folder {
    public string? Name { get; init; }
    public string? Path { get; init; }
    public bool IsExpanded { get; set; }
    public RenderFragment? ChildrenFolders { get; set; }
    public List<Folder> SubFolders { get; set; } = new();
  }

  //private MudListItem? _selectedItem;
  private Folder SelectedFolder { get; set; } = new();
  private Folder? RootFolder { get; set; }
  private string[]? _folders;
  private HubConnection? _directoryHub;

  protected override async Task OnInitializedAsync() {
    await InitializeDirectoryHub();
  }
  private async Task InitializeDirectoryHub() {
    _directoryHub = new HubConnectionBuilder()
      .WithUrl(NavigationManager.ToAbsoluteUri("/directoryHub"))
      .Build();
    _directoryHub.On<string[]>("ReceivedAllFolders", async (folders) => {
  // sort the folders into the dictionary based off of the first folders from the root directory
      _folders = folders;
      RootFolder = BuildDirectoryTree(_folders);
      if (RootFolder != null)
        RootFolder.ChildrenFolders = await ChildrenFolderBuilder(RootFolder);
      await InvokeAsync(StateHasChanged);
    });
    await _directoryHub.StartAsync();
    await _directoryHub.SendAsync("GetAllFolders", null);
  }

  /// <summary>
  /// Builds a directory tree from a collection of file paths.
  /// </summary>
  /// <param name="paths">The file paths to use.</param>
  /// <returns>A directory tree.</returns>
  private static Folder? BuildDirectoryTree(IEnumerable<string> paths) {
  // Check for empty paths
    var enumerable = paths.ToList();
    if (!enumerable.Any()) {
      return null;
    }

  // Find the common part of the paths
    var firstPath = enumerable.First();
    var splitChar = firstPath.Contains('\\') ? '\\' : '/';
    var splitPaths = enumerable.Select(path => path.Split(splitChar)).ToList();
    var commonParts = FindCommonParts(splitPaths);

  // Set the root of the tree to the common part
    var root = new Folder() {
      Name = splitPaths[0][commonParts],
      Path = string.Join(splitChar, splitPaths[0].Take(commonParts + 1)),
      IsExpanded = true,
    };

  // Add the remaining parts to the tree
    foreach (var splitPath in splitPaths) {
      AddRemainingParts(root, splitPath, commonParts);
    }
    return root;
  }

  /// <summary>
  /// Finds the common parts of a collection of split paths.
  /// </summary>
  /// <param name="splitPaths">The collection of split paths.</param>
  /// <returns>The number of common parts.</returns>
  private static int FindCommonParts(IEnumerable<string[]> splitPaths) {
    var commonParts = int.MaxValue;
    var stringsEnumerable = splitPaths.ToList();
    for (var i = 0; i < stringsEnumerable.First().Length; i++) {
      var currentPart = stringsEnumerable.First()[i];
      var count = 1 + stringsEnumerable.Skip(1)
        .TakeWhile(splitPath => i < splitPath.Length && splitPath[i] == currentPart)
        .Count();
      if (count == stringsEnumerable.Count()) {
        commonParts = i;
      } else {
        break;
      }
    }
    return commonParts;
  }

  /// <summary>
  /// Adds the remaining parts of a split path to the directory tree.
  /// </summary>
  /// <param name="root">The root of the directory tree.</param>
  /// <param name="splitPath">The split path.</param>
  /// <param name="commonParts">The number of common parts.</param>
  private static void AddRemainingParts(Folder? root, IReadOnlyList<string> splitPath, int commonParts) {
    var current = root;
    for (var i = commonParts + 1; i < splitPath.Count; i++) {
      var next = current?.SubFolders.FirstOrDefault(f => f.Name == splitPath[i]);
      if (next == null) {
        next = new Folder() {
          Name = splitPath[i],
          Path = current?.Path + splitPath[i],
        };
        current?.SubFolders.Add(next);
      }
      current = next;
    }
  }
  private async Task ToggleFolderExpanded(Folder folder) {
    folder.IsExpanded = !folder.IsExpanded;
    folder.ChildrenFolders = await ChildrenFolderBuilder(folder);
    await InvokeAsync(StateHasChanged);
  }
  /// <summary>
  /// Builds a list of children folders.
  /// </summary>
  /// <param name="baseFolder">The base folder.</param>
  /// <returns>A task that returns a render fragment.</returns>
  private Task<RenderFragment> ChildrenFolderBuilder(Folder baseFolder) {
  // Get a list of child folders in alphabetical order.
  // Then, for each child folder, create a render fragment that renders a MudListItem.
    var index = 0;
    var childrenFolders = baseFolder.SubFolders.OrderBy(f => f.Name).Select(folder => (RenderFragment)(builder => {
      builder.OpenComponent<MudListItem>(index++);
      builder.AddAttribute(index++, "Icon", Icons.Material.Filled.Folder);
      builder.AddAttribute(index++, "Text", folder.Name);
      builder.AddAttribute(index++, "Value", folder);
      if (folder.SubFolders.Any()) {
        builder.AddAttribute(index++, "Inset", true);

      builder.AddAttribute(index++, "ExpandLessIcon", Icons.Material.Filled.ExpandLess);
        builder.AddAttribute(index++, "ExpandMoreIcon", Icons.Material.Filled.ExpandMore);

        builder.AddAttribute(index++, "OnClick", EventCallback.Factory.Create<MouseEventArgs>(this, async () => await ToggleFolderExpanded(folder)));
      builder.AddAttribute(index++, "NestedList", folder.ChildrenFolders);
      }
      builder.CloseComponent();
    })).ToList();

  // Return a render fragment containing all the child folders.
    return Task.FromResult<RenderFragment>(builder => {
      foreach (var child in childrenFolders) {
        child(builder);
      }
    });
  }

  public void Dispose() {
    _directoryHub?.DisposeAsync();
  }
}
