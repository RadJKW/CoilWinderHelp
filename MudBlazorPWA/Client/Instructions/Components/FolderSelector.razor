@inject HubClientService DirectoryHub
@inject ILogger<FolderSelector> Logger
@implements IDisposable
<MudStack Spacing="0"
    Class="mud-height-full">
  <MudPaper Class="left-column-paper mud-height-full"
      Width="300px">

    <MudListExtended T="Folder"
        @ref="SelectableFolders"
        Dense
        Clickable
        DisablePadding
        Class="mud-width-full"
        Style="overflow-y: hidden;"
        MultiSelection="false"
        @bind-SelectedItem="SelectedItem"
        @bind-SelectedValue="SelectedValue">
      <MudListSubheaderExtended T="Folder"
          Class="mud-width-full"
          Sticky="true"
          SecondaryBackground="true">
        @if (_breadCrumbs.Count >= 1) {
          Folder? baseFolder = _breadCrumbs.First();
          <MudStack Row
              Spacing="1"
              Justify="Justify.FlexStart"
              AlignItems="AlignItems.Center">
            <MudTooltip Text="@($"{baseFolder?.Name}")"
                Arrow="true"
                Placement="Placement.Top">
              @* disable icon button if the baseFolder is the only folder in _breadcrumbs*@
              <MudIconButton Icon="@Icons.Material.Outlined.Home"
                  Disabled="@(_breadCrumbs.Count == 1)"
                  Color="Color.Primary"
                  Size="Size.Small"
                  Variant="Variant.Text"
                  OnClick="@(() => SetFolderAsRoot(baseFolder!))"/>
            </MudTooltip>
            @if (_breadCrumbs.Count >= 3) {
              int currentFolderIndex = _breadCrumbs.IndexOf(_breadCrumbs.Last());
              Folder? parentFolder = _breadCrumbs[currentFolderIndex - 1];
              if (parentFolder == null)
                return;
              <strong>/</strong>
              <MudTooltip Text="@($"{parentFolder.Name}")"
                  Arrow
                  ShowOnHover
                  Placement="Placement.Top">
                <MudChip Color="Color.Default"
                    Class="px-1"
                    Size="Size.Small"
                    Variant="Variant.Text"
                    Text="@parentFolder?.Name"
                    OnClick="@(() => SetFolderAsRoot(parentFolder!))">
                </MudChip>
              </MudTooltip>
              }
            @if (_breadCrumbs.Any()) {
              Folder? currentFolder = _breadCrumbs.Last();
              <strong class="px-1">/</strong>
              <strong>@currentFolder?.Name</strong>
            }
          </MudStack>
        }
      </MudListSubheaderExtended>
      @if (RootFolder is not null) {
          var hasSubFolders = false;
          var hasPdfs = false;
          var hasVideos = false;
        foreach (Folder folder in RootFolder.SubFolders.OrderBy(f => f.Name)) {
          if (folder.MediaFiles.PdfFiles != null)
            hasPdfs = folder.MediaFiles.PdfFiles.Any();

          if (folder.MediaFiles.VideoFiles != null)
            hasVideos = folder.MediaFiles.VideoFiles.Any();

          hasSubFolders = folder.SubFolders.Any();
          if (hasSubFolders || hasPdfs || hasVideos){
            <MudListItemExtended T="Folder"
                Icon="@Icons.Material.Filled.Folder"
                Text="@folder.Name"
                Value="@folder"
                OnClick="SetFolderAsRoot">
            </MudListItemExtended>
          }
        }
        if (!hasSubFolders && !hasPdfs && !hasVideos) {
          <div class="pa-4">

          </div>
        }
        if (_breadCrumbs.Count > 1) {
          <MudListSubheaderExtended T="string" Sticky="true"
              SecondaryBackground="true">
            Folders
          </MudListSubheaderExtended>
          <MudDropZone T="DropItem"
              Identifier="Drop Zone 0"
              Class="align-center d-flex flex-row flex-wrap gap-1 justify-center justify-center mud-background py-1"
              Style="max-height: 30%; overflow-y: auto; overflow-x: hidden;">
            <ItemRenderer>
              <MudChip Text="@context.Name"
                  Class="cursor-grab"
                  Style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"
                  Icon="@Icons.Material.Outlined.Folder"
                  Size="Size.Small"
                  Label="true">
              </MudChip>
            </ItemRenderer>
          </MudDropZone>
        }
        if (RootFolder.MediaFiles.PdfFiles != null && RootFolder.MediaFiles.PdfFiles.Any()) {
          <MudListSubheaderExtended T="string"
              Sticky="true"
              SecondaryBackground="true">
            PDFs
          </MudListSubheaderExtended>
          <MudDropZone T="DropItem"
              Identifier="DZ-PDF"
              Class="align-center d-flex flex-row flex-wrap gap-1 justify-center justify-center mud-background py-1"
              Style="max-height: 30%; overflow-y: auto; overflow-x: hidden;">
            <ItemRenderer>
              <div class="mud-width-full d-flex justify-center">

              <MudChip Class="cursor-grab"
                  Style="height: auto; max-width: 75%;"
                  Icon="@Icons.Material.Outlined.PictureAsPdf"
                  Size="Size.Small"
                  Label="true">
                <div class="d-flex justify-center mud-width-full">

                  <p style="white-space: pre-wrap; margin: 4px; width: 75%">@context.Name</p>
                </div>
              </MudChip>
              </div>
            </ItemRenderer>
          </MudDropZone>
        }

        if (RootFolder.MediaFiles.VideoFiles != null && RootFolder.MediaFiles.VideoFiles.Any()) {
          <MudListSubheaderExtended T="string"
              Sticky="true"
              SecondaryBackground="true">
            Videos
          </MudListSubheaderExtended>
          <MudDropZone T="DropItem"
              Identifier="DZ-Video"
              Class="align-center d-flex flex-row flex-wrap gap-1 justify-center justify-center mud-background py-1"
              Style="max-height: 30%; overflow-y: auto; overflow-x: hidden;">
            <ItemRenderer>
              <MudChip Class="cursor-grab"
                  Icon="@Icons.Material.Outlined.Movie"
                  Size="Size.Small"
                  Label="true">
                 <p style="white-space: pre-wrap; margin-block: 4px">@context.Name</p>
              </MudChip>
            </ItemRenderer>
          </MudDropZone>
        }
      }

    </MudListExtended>
  </MudPaper>
</MudStack>

@code {
  [Parameter]
  public EventCallback<Folder[]?> OnFoldersSubmitted { get; set; }
  [Parameter]
  public EventCallback<Folder> OnFolderSelected { get; set; }
  [Parameter]
  public string? DirectoryPath { get; set; }

    private const string PdfDropZoneId = "DZ-PDF";
    private const string VideoDropZoneId = "DZ-Video";

  #region Properties
  private readonly List<Folder?> _breadCrumbs = new();
  private MudListExtended<Folder>? SelectableFolders { get; set; }
  private MudListExtended<Folder>? SelectedFoldersList { get; set; }
  private MudListItemExtended<Folder?>? SelectedItem { get; set; }
  private Folder? SelectedValue { get; set; }
  private Folder? RootFolder { get; set; }
  private string[]? _folders;
  #endregion

  protected override async Task OnInitializedAsync() {
    var enumerable = await DirectoryHub.GetFoldersInPath();
    OnReceiveAllFolders(enumerable);
    await OnFolderSelected.InvokeAsync(RootFolder);
    await base.OnInitializedAsync();
  }
  private void OnReceiveAllFolders(IEnumerable<string> folders) {
    _folders = folders.Select(f => f.Insert(0, DirectoryHub.WindingDocsFolder)).ToArray();
    RootFolder = BuildDirectoryTree(_folders);
    _breadCrumbs.Add(RootFolder);
    InvokeAsync(StateHasChanged);
  }
  public void Dispose() {
    DirectoryHub.ReceiveAllFolders -= OnReceiveAllFolders;
  }

  private async Task SetFolderAsRoot() {
    if (SelectedValue == null)
      return;

    RootFolder = SelectedValue;
    await ConvertMediaFilesToDropItems(RootFolder);
    _breadCrumbs.Add(SelectedValue);
    await SubmitSelectedFolders();
  }
  private async Task SetFolderAsRoot(Folder newRoot) {
  // remove the newRoot from _breadCrumbs and all following items
    int index = _breadCrumbs.IndexOf(newRoot);
    _breadCrumbs.RemoveRange(index, _breadCrumbs.Count - index);
    RootFolder = newRoot;
    await ConvertMediaFilesToDropItems(RootFolder);
    _breadCrumbs.Add(newRoot);
    SelectableFolders!.Clear();
    await SubmitSelectedFolders();
  }
  private Task NavigateToFolder(Folder folder) {
    RootFolder = folder;
    _breadCrumbs.Add(folder);
    return SubmitSelectedFolders();
  }
  private async Task SubmitSelectedFolders() {
    await OnFolderSelected.InvokeAsync(_breadCrumbs.Last());
    await OnFoldersSubmitted.InvokeAsync(_breadCrumbs.Last()?.SubFolders.ToArray());
  }

  #region Static Methods
  /// <summary>
  /// Builds a directory tree from a collection of file paths.
  /// </summary>
  /// <param name="paths">The file paths to use.</param>
  /// <returns>A directory tree.</returns>
  private static Folder? BuildDirectoryTree(IEnumerable<string> paths) {
  // Check for empty paths
    var enumerable = paths.ToList();
    if (!enumerable.Any()) {
      return null;
    }
  // Find the common part of the paths
    string firstPath = enumerable.First();
    char splitChar = firstPath.Contains('\\') ? '\\' : '/';
    var splitPaths = enumerable.Select(path => path.Split(splitChar)).ToList();
    int commonParts = FindCommonParts(splitPaths);
  // Set the root of the tree to the common part
    var root = new Folder(splitPaths[0][commonParts], string.Join(splitChar, splitPaths[0].Take(commonParts + 1)), splitChar);
  // Add the remaining parts to the tree
    foreach (string[] splitPath in splitPaths) {
      AddRemainingParts(root, splitPath, commonParts);
    }
    return root;
  }

  /// <summary>
  /// Finds the common parts of a collection of split paths.
  /// </summary>
  /// <param name="splitPaths">The collection of split paths.</param>
  /// <returns>The number of common parts.</returns>
  private static int FindCommonParts(IEnumerable<string[]> splitPaths) {
    var commonParts = int.MaxValue;
    var stringsEnumerable = splitPaths.ToList();
    for (var i = 0; i < stringsEnumerable.First().Length; i++) {
      string currentPart = stringsEnumerable.First()[i];
      int count = 1 + stringsEnumerable.Skip(1)
        .TakeWhile(splitPath => i < splitPath.Length && splitPath[i] == currentPart)
        .Count();
      if (count == stringsEnumerable.Count()) {
        commonParts = i;
      } else {
        break;
      }
    }
    return commonParts;
  }

  /// <summary>
  /// Adds the remaining parts of a split path to the directory tree.
  /// </summary>
  /// <param name="root">The root of the directory tree.</param>
  /// <param name="splitPath">The split path.</param>
  /// <param name="commonParts">The number of common parts.</param>
  private static void AddRemainingParts(Folder? root, IReadOnlyList<string> splitPath, int commonParts) {
    Folder? current = root;
    for (int i = commonParts + 1; i < splitPath.Count; i++) {
      Folder? next = current?.SubFolders.FirstOrDefault(f => f.Name == splitPath[i]);
      if (next == null) {
        next = new(splitPath[i], current?.Path + current?.SplitChar + splitPath[i], current!.SplitChar);
        current.SubFolders.Add(next);
      }
      current = next;
    }
  }
  #endregion

  private string GetNameWithParent(string folderName) {
    string? path = _folders?.FirstOrDefault(f => f.EndsWith(folderName));
    if (path == null)
      return folderName;

    char splitChar = path.Contains('\\') ? '\\' : '/';
    string[] splitPath = path.Split(splitChar);
    string parent = splitPath[^2];
    return $"{parent}{splitChar}{folderName}";
  }
  // TODO: call this method when RootFolder is set for the first time only,
  // remove the recursive blocker.
  private async Task ConvertMediaFilesToDropItems(Folder rootFolder) {
  // if Pdf Files is not null, add drop items if not already added
    Logger.LogInformation("ConvertMediaFilesToDropItems Started");
    var (pdfFiles, videoFiles) = await DirectoryHub.ListMediaFiles(rootFolder.Path);
    rootFolder.MediaFiles.PdfFiles = pdfFiles;
    rootFolder.MediaFiles.VideoFiles = videoFiles;


    rootFolder.DropItems.AddRange(rootFolder.MediaFiles.PdfFiles
      .Where(f => rootFolder.DropItems.All(d => d.Path != f))
      .Select(f => new DropItem {
        Name = f.Split("/").Last(),
        Path = f,
        Type = DropItemType.Pdf,
        Identifier = PdfDropZoneId
      }));

    rootFolder.DropItems.AddRange(rootFolder.MediaFiles.VideoFiles
      .Where(f => rootFolder.DropItems.All(d => d.Path != f))
      .Select(f => new DropItem {
        Name = f.Split("/").Last(),
        Path = f,
        Type = DropItemType.Video,
        Identifier = VideoDropZoneId
      }));

    Logger.LogInformation("Calling ConvertMediaFilesToDropItems Recursive");

    if (rootFolder.Name != RootFolder?.Name || !rootFolder.SubFolders.Any())
      return;
    foreach (Folder subFolder in rootFolder.SubFolders) {
      await ConvertMediaFilesToDropItems(subFolder);
    }

  }
}
