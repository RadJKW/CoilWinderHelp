@inject AdminEditorState State
@using System.Text.Json
@implements IDisposable

@if (State.RootDirectoryItem != null) {
  <div @attributes="@AdditionalAttributes">
    <MudListSubheaderExtended T="string"
        DisableGutters="true"
        SecondaryBackground="true">
      <MudStack Row
          Spacing="6"
          AlignItems="AlignItems.Center"
          Justify="Justify.Center">
        <MudIcon Icon="@Icons.Material.Filled.DatasetLinked"/>
        <MudText Typo="Typo.h5">
          <strong >Winding Instructions</strong>
        </MudText>
      </MudStack>
    </MudListSubheaderExtended>
    <div class="directory-explorer">
      <div class="directory-treeview">
        <MudTreeView T="IDirectoryItem"
            @bind-SelectedValue="@State.SelectedItem"
            ServerData="@(item => InvokeFetchTreeItems(item, "ServerData"))"
            MaxHeight="100%"
            Dense="true"
            Hover="true"
            Width="100%">
          <ChildContent>
            @{
              var rootItem = State.RootDirectoryItem;
              <MudTreeViewItem T="IDirectoryItem"
                  Items="@rootItem.TreeItems"
                  Icon="@Icons.Material.Filled.FolderSpecial"
                  Value="@rootItem"
                  Text="@rootItem.Name"
                  Activated="@(rootItem == State.SelectedItem)"
                  @bind-Expanded="@rootItem.Expanded"/>
            }
          </ChildContent>
          <ItemTemplate Context="item">
            <MudTreeViewItem T="IDirectoryItem"
                Items="@item.TreeItems"
                Value="@item"
                Expanded="item.Expanded"
                ExpandedChanged="(expanded) => OnItemExpanded(item, expanded)">

              <Content>
                <MudTreeViewItemToggleButton Loading="@item.Loading"
                    Expanded="item.Expanded"
                    ExpandedChanged="(expanded) => OnItemExpanded(item, expanded)"
                    Visible="item.CanExpand"
                    ExpandedIcon="@Icons.Material.Filled.ChevronRight"
                    LoadingIcon="@Icons.Material.Filled.Loop"
                    LoadingIconColor="Color.Info"/>
                <MudIcon Icon="@item.Icon"/>
                <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%">
                  <MudText Class="pl-2"
                      Style="justify-self: start;">
                    @item.Name
                  </MudText>
                  @if (item.ItemType is ItemType.File) {
                    <div style="justify-self: end;">

                      <MudIconButton Icon="@Icons.Material.Filled.OpenInBrowser"
                          OnClick="@(() => OpenFilePreview(item))"
                          Size="Size.Small"
                          Color="Color.Inherit"/>
                      <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                          Size="Size.Medium"
                          Color="Color.Inherit"/>
                    </div>
                  }
                </div>
              </Content>

            </MudTreeViewItem>
          </ItemTemplate>

        </MudTreeView>
      </div>
    </div>
  </div>
}


@code{

  [Parameter(CaptureUnmatchedValues = true)]
  public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }
  private MudTreeView<IDirectoryItem> MudTreeRoot { get; set; } = new();


  protected override async Task OnInitializedAsync() {
    await base.OnInitializedAsync();
    State.StateChanged += AdminStateChanged;
  }

  protected override async Task OnAfterRenderAsync(bool firstRender) {
    await base.OnAfterRenderAsync(firstRender);
    if (firstRender) {
      await State.BuildDirectoryTree();
    }
  }
  private void AdminStateChanged() => StateHasChanged();
  public void Dispose() { State.StateChanged -= AdminStateChanged; }

  private async Task OnItemExpanded(IDirectoryItem item, bool expanded) {
  // prevents parent from collapsing when child or grandchild is selected


    if (item.Expanded != expanded) {
      item.Expanded = expanded;
      StateHasChanged();
      await InvokeFetchTreeItems(item, "TreeViewItem");
      StateHasChanged();
      await Task.Delay(250);
      item.Loading = false;
    }
  }
  private async Task<HashSet<IDirectoryItem>> InvokeFetchTreeItems(IDirectoryItem item, string componentId) {
    if (item.TreeItems != null && item.TreeItems.Any()) return new(item.TreeItems);
    item.Loading = true;
    StateHasChanged();
    await DirectoryExtensions.FetchTreeItems(item);
    return item.TreeItems == null
      ? new()
      : new(item.TreeItems);
  }

  private async Task OpenFilePreview(IDirectoryItem item) {
    if (item is not DirectoryItem<FileNode> file) return;
    if (file.Item?.Path != null)
      await State.OpenFilePreview(file.Item.Path);
  }
  private void UpdateSelectedItem(IDirectoryItem? arg) {
    if (arg is null) return;
    if (arg == State.SelectedItem) return;
    State.SelectedItem = arg;
  }
}
